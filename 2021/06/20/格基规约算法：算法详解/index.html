<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="格基规约算法：算法详解"><meta name="keywords" content="格论（几何数论）,格基规约算法,格密码学"><meta name="author" content="随缘(su1yu4n)"><meta name="copyright" content="随缘(su1yu4n)"><title>格基规约算法：算法详解 | 随缘的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.0.0'
} </script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="随缘的博客" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%A0%BC%E5%9F%BA%E8%A7%84%E7%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">原始格基规约算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">高斯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">算法效能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLL%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">LLL算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">简易实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">常规实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E6%95%88%E8%83%BD"><span class="toc-number">1.2.4.</span> <span class="toc-text">理论效能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BKZ%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">BKZ算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E6%95%88%E8%83%BD-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">理论效能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%AF%E5%8F%91"><span class="toc-number">1.4.</span> <span class="toc-text">总结与启发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E6%A0%BC%E5%9F%BA%E7%BA%A6%E5%8C%96%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">改进格基约化算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mathrm-L-2-%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">$\mathrm{L}^{2}$算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BKZ-2-0"><span class="toc-number">2.2.</span> <span class="toc-text">BKZ 2.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">2.3.</span> <span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E7%8C%AE"><span class="toc-number">3.1.</span> <span class="toc-text">文献</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%9A%E5%AE%A2"><span class="toc-number">3.2.</span> <span class="toc-text">博客</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://su1yu4n.github.io/images/avatar_miku.png"></div><div class="author-info__name text-center">随缘(su1yu4n)</div><div class="author-info__description text-center">Nepnep棺材板，XDSEC潜水员，CTF纯业余。发一些数学密码学和技术相关的内容，以及个人相关的内容。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friends</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://ziyangzhu.github.io/home/">Ziyang ZHU</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://shal10w.github.io/">shallow</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.h3h3qaq.cn/">H3h3QAQ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://Lord-Riot.github.io">Lord Riot</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/y-f00l/skr-lab">youn9</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.soreatu.com/">soreatu</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.scraft.top/">暮光小猿wzt</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://shakaianee.top/">社会易姐QwQ</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.wh1sper.com/">wh1sper</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com/yuligesec">郁离歌</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://link.fffmath.com/">fffmath</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45935647">1jt</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.csdn.net/jcbx_">gm1y</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">随缘的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">格基规约算法：算法详解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 22 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong>本文详细了介绍原始格基规约算法</strong>，并<strong>简单介绍目前对算法的改进</strong>。这些改进算法非常实用，被广泛应用于密码分析中。</p>
<p>阅读本篇前需要先了解格论，可以先看看<a href="/2021/06/20/%E6%A0%BC%E5%9F%BA%E8%A7%84%E7%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" title="格基规约算法：数学基础">格基规约算法：数学基础</a></p>
<span id="more"></span>
<p>&nbsp;</p>
<h1 id="原始格基规约算法"><a href="#原始格基规约算法" class="headerlink" title="原始格基规约算法"></a>原始格基规约算法</h1><h2 id="高斯算法"><a href="#高斯算法" class="headerlink" title="高斯算法"></a>高斯算法</h2><p>在18到19世纪间，拉格朗日和高斯先后提出了<strong>一种二维格基规约算法</strong>，现今称为高斯算法。下面介绍<strong>原始的高斯算法</strong>。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p><em>以下内容基本来自 Lattice Basis Reduction: An Introduction to the LLL Algorithm and its Application .</em></p>
<p>首先先给出算法中出现的概念和符号。</p>
<ul>
<li><p><strong>最小基</strong>：设$\, \mathbf{x},\mathbf{y}\,$是二维格$\,\mathcal{L}\subset\mathbb{R}^2\,$的一组基。若$\, \mathbf{x},\mathbf{y}\,$满足$\,\left | \mathbf{x}\right | =\lambda_1\left(\mathcal{L}\right)\,$ 且$\, \mathbf{y}\,$是与$\, \mathbf{x}\,$线性无关的一个最短向量，则称$\, \mathbf{x},\mathbf{y}\,$是最小的(minimal)。最小基也被称为<strong>Minkowski约化基</strong>。</p>
</li>
<li><p>取整：记$\, \lceil\mu\rfloor\,$为距$\,\mu\,$最近的整数，即$\, \lceil\mu\rfloor=\left\lceil\mu-\frac{1}{2}\right\rceil\,$。我们规定对于整数$\,n\,$，$\lceil n+\frac{1}{2}\rfloor\,$的值为$\, n\,$ 。</p>
</li>
</ul>
<p>下面给出高斯算法的伪代码描述。</p>
<ul>
<li>输入：$\mathbb{R}^2$上的二维格$\mathcal{L}$的一组基 $\mathbf{x},\mathbf{y}$，其中$\left|\mathbf{x}\right|&lt;\left|\mathbf{y}\right|$</li>
<li>输出：格$\,\mathcal{L}\,$的一组最小基$\,\mathbf{v}_1,\mathbf{v}_2$</li>
<li>算法步骤：<a href="Gauss_algo.png">高斯算法伪代码</a></li>
</ul>
<p>高斯算法中蕴含的思想与欧几里得算法类似，两者都是不断地实施<strong>先约化后交换</strong>的策略。在伪代码中，<strong>(2)(b)是约化步，(2)(c)(ii)是交换步</strong>。在约化步中会计算施密特正交化的系数，并且为了确保在格$\,\mathcal{L}\,$上运算，不能直接用施密特正交化系数，而是<strong>要将其取整后</strong>得到的$\,m\,$作为约化步中减去$\,\mathbf{v}_2\,$的系数。当$\, \left|\mathbf{v}_1\right|\le\left|\mathbf{v}_2\right|\,$时，算法结束并输出此时的${\, \mathbf{v}}_1\,$和${\ \mathbf{v}}_2\,$。可以证明算法输出的${\ \mathbf{v}}_1$和${\ \mathbf{v}}_2\,$是一组最小基，下面简述证明思路。</p>
<p>证明思路：首先，由取整的定义易知在算法的步骤(2)(b)执行后，有$\,\left|\mathbf{v}_2^\prime\cdot\mathbf{v}_1\right|\le\frac{1}{2}\left|\mathbf{v}_1\right|^2\,$，其中$\, \mathbf{v}_2^\prime\,$是步骤执行后所得新基的第二个向量。或者说，<strong>每次(2)(b)执行完毕后有 $\mu_{2,1} \le \frac{1}{2}$</strong>（此时称${\, \mathbf{v}}_1,{\ \mathbf{v}}_2\,$是 size-reduced的）。<strong>结合算法终止时$\, \left|\mathbf{v}_1\right|\le\left|\mathbf{v}_2\right|\,$这一条件即可证明</strong>$\, \left|\mathbf{v}_1\right| = \lambda_{1}(\mathcal{L}) \,$。这一点从几何上非常直观，读者不妨考虑一下$\, \left|\mathbf{v}_1\right| = \left|\mathbf{v}_2\right|\,$时的情形。接下来再证$\,\mathbf{v}_2\,$是与$\,\mathbf{v}_1\,$线性无关的最短向量即可（证这一步有点繁琐）。</p>
<p>上述证明思路来源于二维空间上的几何直观，后面会看到在高维格中无法用类似的思路证明。在高维空间中，长度（2-范数）就没那么符合直觉了。由此也能侧面理解，为什么SVP问题在低维格中是容易的，在高维格中是困难的。</p>
<p>纵观高斯算法的流程，其实就是在不停地<strong>让两个向量互相约化，直到它们无法变得更短为止</strong>。因此，<strong>高斯算法可以视为一种贪心算法</strong>，且可以推广至高维（见后面的推广高斯算法）。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>sagemath代码</strong>如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Gauss</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="comment"># step 1</span></span><br><span class="line">    v1 = x; v2 = y</span><br><span class="line">    finished = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># step 2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> finished:</span><br><span class="line">        <span class="comment"># (a)</span></span><br><span class="line">        m = <span class="built_in">round</span>(( v2.dot_product(v1) / v1.dot_product(v1) ))</span><br><span class="line">        <span class="comment"># (b)</span></span><br><span class="line">        v2 = v2 - m*v1</span><br><span class="line">        <span class="comment"># (c)</span></span><br><span class="line">        <span class="keyword">if</span> v1.norm() &lt;= v2.norm():</span><br><span class="line">            finished = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v1, v2 = v2, v1</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> v1, v2</span><br></pre></td></tr></table></figure>
<h3 id="算法效能"><a href="#算法效能" class="headerlink" title="算法效能"></a>算法效能</h3><p>高斯算法能够<strong>以平方级别的运行时间求解出一组Minkowski约化基（最小基）</strong>，具体如下。</p>
<ul>
<li>约化能力：设$\, \mathbf{x},\mathbf{y}\in\mathbb{R}^\mathbf{2}\,$是二维格$\,\mathcal{L}\,$的一组基，将$\mathbf{x},\mathbf{y}$作为高斯约化算法的输入，则算法一定能够在有限步内执行完成，且其输出的$\ \mathbf{v}_1,\mathbf{v}_2\,$是格$\,\mathcal{L}\,$的一组Minkowski约化基。</li>
<li>运行时间：输入二维格$\,\mathcal{L}\,$的任意一组基$\,\mathbf{u},\mathbf{v}\,$，假设$\, \left|\mathbf{u}\right|\le\left|\mathbf{v}\right|\,$，那么高斯算法会在$\, O\left(\log\left|\mathbf{v}\right|\cdot\left[1+\log\left|\mathbf{v}\right|-\log\lambda_1\left(\mathcal{L}\right)\right]\right)\,$的时间内运行完毕。</li>
</ul>
<h2 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h2><p>1982年诞生的LLL算法可视为高斯算法在高维格中的推广。接下来详细介绍原始LLL算法。</p>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>设$\ \mathcal{L}\subset\mathbb{R}^m\,$是$\,n\,$维格，算法输入$\, \mathcal{L} \,$的任意一组基，并以多项式时间输出一组LLL约化基。首先介绍LLL约化基的概念。</p>
<p><strong>LLL约化基</strong>：设$\, \mathbf{b}_1,\ldots,\mathbf{b}_n \,$是$\, \mathcal{L}\,$的一组格基，若其满足以下两个性质：</p>
<ol>
<li><strong>(size-reduce)</strong>：对于任意的$\, j&lt;i\le n\,$，有$\, \left|\mu_{i,j}\right| \le \frac{1}{2}\,$，其中$\,\mu_{i,j}=\frac{\left\langle\mathbf{b}_i,\mathbf{b}_j^\ast\right\rangle}{\left\langle\mathbf{b}_j^\ast,\mathbf{b}_j^\ast\right\rangle}\,$为施密特正交化中的系数。</li>
<li><strong>(Lovász condition)</strong>：对于任意的$\,\mathbf{b}_i,\ \mathbf{b}_{i+1}\,$有$\,\delta\left| \mathbf{b}_i^\ast \right|^2\le\left|\mathbf{b}_{i+1}^\ast+\mu_{i+1,i}\mathbf{b}_i^\ast \right|^2\,$.</li>
</ol>
<p>则称$\, \mathbf{b}_1,\ldots,\mathbf{b}_n \,$是$\, \mathcal{L}\,$的一组<strong>$\delta-$LLL约化基</strong>。</p>
<p>性质2中的不等式$\,\delta\left| \mathbf{b}_i^\ast \right|^2\le\left|\mathbf{b}_{i+1}^\ast+\mu_{i+1,i}\mathbf{b}_i^\ast \right|^2\,$可以等价替换为$\, \left| \mathbf{b}_{i+1}^\ast \right|^2 \ge \left(\delta - \mu^{2}_{i+1,i} \right)\left| \mathbf{b}_{i}^\ast \right|^2 \ge \left(\delta - \frac{1}{4} \right)\left| \mathbf{b}_{i}^\ast \right|^2 \,$。性质1表明，LLL约化基中的向量是<strong>相对较短且近似正交</strong>的。性质2是为了根据范数对基中向量进行大致的排序。    </p>
<p>下面给出LLL算法的伪代码：</p>
<p><a href="LLL_algo.png">原始LLL算法伪代码</a></p>
<h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><p><strong>sagemath</strong>代码如下，参考 <a target="_blank" rel="noopener" href="https://kel.bz/post/lll/">https://kel.bz/post/lll/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LLL_v0</span>(<span class="params">M, delta=<span class="number">0.75</span></span>):</span><br><span class="line">    B = deepcopy(M)</span><br><span class="line">    Q, mu = B.gram_schmidt()</span><br><span class="line">    n, k = B.nrows(), <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> k &lt; n:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># size reduction step</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(k)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>( mu[k][j] ) &gt; <span class="number">0.5</span>:</span><br><span class="line">                B[k] = B[k] - <span class="built_in">round</span>( mu[k][j] ) * B[j]</span><br><span class="line">                Q, mu = B.gram_schmidt()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># swap step </span></span><br><span class="line">        <span class="keyword">if</span> Q[k].dot_product(Q[k]) &gt;= (delta - mu[k][k-<span class="number">1</span>]^<span class="number">2</span>) * Q[k-<span class="number">1</span>].dot_product(Q[k-<span class="number">1</span>]):</span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            B[k], B[k-<span class="number">1</span>] = B[k-<span class="number">1</span>], B[k]</span><br><span class="line">            Q, mu = B.gram_schmidt()</span><br><span class="line">            k = <span class="built_in">max</span>(k-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B </span><br></pre></td></tr></table></figure>
<h3 id="常规实现"><a href="#常规实现" class="headerlink" title="常规实现"></a>常规实现</h3><p>在进行一次交换步或约化步之后，实际上只需要修改mu（施密特正交化系数）和Q（正交向量组）的个别值。而简易实现中，每次都会重新计算整个施密特正交化，这样的实现是低效的。</p>
<p>参考的伪代码不贴了，来源于 Lattice Basis Reduction - An Introduction to the LLL Algorithm and its Applications P.63 </p>
<p><strong>sagemath</strong>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">LLL_v1</span>(<span class="params">M, delta=<span class="number">0.75</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> delta &lt; <span class="number">0.25</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;delta should be greater than 0.25. Choose delta = 0.75 now.&quot;</span>)</span><br><span class="line">    alpha = delta <span class="keyword">if</span> <span class="number">0.25</span> &lt; delta &lt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.75</span></span><br><span class="line">    </span><br><span class="line">    x = M</span><br><span class="line">    n = M.nrows()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reduce</span>(<span class="params">k, l</span>):</span><br><span class="line">        do_reduce = <span class="literal">False</span></span><br><span class="line">                   </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(mu[k,l]) &gt; <span class="number">0.5</span>:</span><br><span class="line">            do_reduce = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            y[k] = y[k] - mu[k,l].<span class="built_in">round</span>() * y[l]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                mu[k,j] -=  mu[k,l].<span class="built_in">round</span>() * mu[l,j]</span><br><span class="line">            mu[k,l] = mu[k,l] - mu[k,l].<span class="built_in">round</span>()       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">k</span>):</span><br><span class="line">        </span><br><span class="line">        y[k-<span class="number">1</span>], y[k] = y[k], y[k-<span class="number">1</span>]</span><br><span class="line">        NU = mu[k,k-<span class="number">1</span>]</span><br><span class="line">        delta = gamma[k] + NU ^ <span class="number">2</span> * gamma[k-<span class="number">1</span>]</span><br><span class="line">        mu[k,k-<span class="number">1</span>] = NU * gamma[k-<span class="number">1</span>] / delta    <span class="comment"># all above is right</span></span><br><span class="line">        gamma[k] = gamma[k] * gamma[k-<span class="number">1</span>] / delta</span><br><span class="line">        gamma[k-<span class="number">1</span>] = delta</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            mu[k-<span class="number">1</span>,j], mu[k,j] = mu[k,j], mu[k-<span class="number">1</span>,j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>, n):</span><br><span class="line">            xi = mu[i,k]</span><br><span class="line">            mu[i,k] = mu[i,k-<span class="number">1</span>] - NU * mu[i,k]</span><br><span class="line">            mu[i,k-<span class="number">1</span>] = mu[k,k-<span class="number">1</span>] * mu[i,k] + xi      </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step (1) </span></span><br><span class="line">    y = deepcopy(x)</span><br><span class="line">    <span class="comment"># step (2) </span></span><br><span class="line">    y_star, mu = y.gram_schmidt()</span><br><span class="line">    gamma = [y_star[i].norm() ^ <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step (3)</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step (4)</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; n:      </span><br><span class="line">        <span class="comment"># step (4)(a)    </span></span><br><span class="line">        reduce(k, k-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step (4)(b)</span></span><br><span class="line">        <span class="keyword">if</span> gamma[k] &gt;= (alpha - mu[k,k-<span class="number">1</span>]^<span class="number">2</span>) * gamma[k-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># (i)</span></span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(k-<span class="number">1</span>)):</span><br><span class="line">                reduce(k, l)</span><br><span class="line">            <span class="comment"># (ii)</span></span><br><span class="line">            k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># (iii)</span></span><br><span class="line">            exchange(k)</span><br><span class="line">            <span class="comment"># (iv)</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">1</span>:</span><br><span class="line">                k = k-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>注：这两个版本的算法输出会有所不同，但这并不是因为代码写的有错误。两个算法求出的结果都是一组LLL-约化基。</em></p>
<h3 id="理论效能"><a href="#理论效能" class="headerlink" title="理论效能"></a>理论效能</h3><p>在密码分析的使用中，一般会选取$\,\delta=0.99\,$或其他合适的值。我们最关心LLL求解SVP的能力，下面给出$\, \delta\,$取任意值时所得$\, \mathbf{b}_1\,$范数的上界。</p>
<p><strong>约化能力</strong>：设$\, \mathbf{b}_1,\ldots,\mathbf{b}_n\,$是$\, n\,$维格$\, \mathcal{L}\,$的一组$\ \delta\,$- LLL约化基，则$\ \left| \mathbf{b}_1\right| \le\left(\frac{2}{\sqrt{4\delta-1}}\right)^{n-1}\lambda_1(\mathcal{L})\,$。</p>
<p>由定理可知，在LLL中$\, \delta\,$的选取会显著影响输出基的质量，$\, \delta\,$越大则基的范数越小。但算法中$\, \delta&lt;1\ ,$，因此常见的选取为$\, \delta=0.99\,$。根据定理3.2.2，此时$\, \left|\mathbf{b}_1\right|&lt;\left(1.35136\right)^\frac{n-1}{2}\lambda_1(\mathcal{L})\,$。</p>
<p>实际上，<strong>LLL算法输出基的质量在实践中一般优于上述定理给出的上界，以此估算LLL的实际表现是悲观的</strong>。与此相似，<strong>下面给出的时间复杂度上界也是一个悲观估计</strong>。</p>
<p><strong>时间复杂度</strong>：设$\, \mathcal{L}\subset\mathbb{R}^m\,$为$\, n\,$维格，LLL算法输入基为$\, \mathbf{b}_1,\ldots,\mathbf{b}_n\,$，则LLL算法会在$\ O\left(n^6\ln^3\!{B}\right)\,$的时间内运行完毕。其中$\ \forall1\le i\le n\ ,\ \left|\mathbf{b}_i\right|&lt;B\ .$</p>
<p>LLL算法的理论效能总结如下：算法能够在$\ O\left(n^6\ln^3{B}\right)\,$的时间内，输出质量较高的约化基。当算法中的参数选取为$\, \delta=0.99\,$时，输出基中第一个向量的欧氏范数满足$\, \left|\mathbf{b}_1\right|&lt;\left(1.352\right)^\frac{n-1}{2}\lambda_1(\mathcal{L})\,$。再次强调，<strong>这些结论仅仅是算法性能的下限</strong>，直接用这些值来预测算法性能过于悲观。后面还会看到，改进LLL算法的时间复杂度明显优于这个上界。</p>
<h2 id="BKZ算法"><a href="#BKZ算法" class="headerlink" title="BKZ算法"></a>BKZ算法</h2><p>1994年，Schnorr等人提出了BKZ算法。该算法<strong>比LLL算法的约化能力更强</strong>，可视为LLL算法的一种改进，其中使用了KZ约化(Korkin-Zolotarev reduction)和深插法(deep insertion)。下面介绍原始BKZ算法，而目前使用的BKZ 2.0在后面介绍。</p>
<h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p><strong>KZ约化</strong>：KZ约化基是一组size-reduced，且<strong>其正交化后的向量范数为逐次最小长度的格基</strong>（特别地，基中第一个向量的长度即为$\,\lambda_1\,$）。计算高维格的KZ约化基是不切实际的，因为这需要要在输入格的投影子格上对SVP求解算法进行迭代式调用，其时间复杂度一般为超指数级。</p>
<p>为了<strong>以合理的时间代价得到比LLL约化基质量更好的基</strong>，Schnorr等人提出让格基的<strong>每个分块为KZ约化基</strong>即可。并且在原始BKZ中，分块的大小一般只会选取为10~30左右。下面给出BKZ约化基的概念。</p>
<p><strong>BKZ约化</strong>：若$\, {\mathbf{b}}_1,\ldots,\mathbf{b}_n\,$为格$\,\mathcal{L}\,$的LLL约化基，且对于任意的$\,i\,$，有</p>
<p><script type="math/tex">\ \left\|\mathbf{b}_i^\ast\right\|=\lambda_1\left(\mathcal{L}_{\left[i,min{\left(i+\beta-1,n\right)}\right]}\right)\</script>，</p>
<p>则称${\ \mathbf{b}}_1,\ldots,\mathbf{b}_n\,$为格$\,\mathcal{L}\,$的一组$\,\beta-$BKZ约化基，称其中的$\, \beta\,$为BKZ的分块大小。<br>    在BKZ算法中，<strong>只需在分块投影子格$\, \mathcal{L}([\pi_i(\mathbf{b}_i),\pi_i(\mathbf{b}_{i+1}),\ldots,\pi_i(\mathbf{b}_{min\left(i+\beta-1,n\right)})]) \,$上求解SVP</strong>，这要比KZ约化容易得多。BKZ中这个求解SVP的子算法称为<strong>SVP oracle，一般使用格枚举(lattice enumeration)实现</strong>。</p>
<p><strong>原始的BKZ</strong>使用<strong>精确格枚举算法</strong>，这个算法一定能够在输入投影子格上求解出SVP，但它的时间开销很大。实用的BKZ使用的是<strong>剪枝枚举算法</strong>，这种算法只能以一定的概率求解SVP，但它的时间开销比前者小很多。</p>
<p><em>枚举算法可视为对枚举树的DFS，剪枝枚举则是剪枝DFS。</em></p>
<p><strong>原始BKZ伪代码</strong>如下。<br>        <strong>输入</strong>：格$\,\mathcal{L}\,$的基$\ B={(\mathbf{b}}_1,\ldots,\mathbf{b}_n)\,$，分块大小$\, \beta\in\left\{2,\ldots,n\right\}\,$，施密特系数矩阵$\, \mu\,$和${\, \left|\mathbf{b}_1^\ast\right|}^2,\ldots,\left|\mathbf{b}_n^\ast\right|^2 \,$<br>        <strong>输出</strong>：$\,\beta-$BKZ约化基$\, {(\mathbf{b}}_1,\ldots,\mathbf{b}_n)\,$</p>
<p><strong>算法步骤</strong>：</p>
<p><a href="BKZ_algo.png">原始BKZ算法伪代码</a></p>
<p>BKZ算法的<strong>大致流程</strong>如下：</p>
<p>先对输入基进行LLL作为预处理，之后对当前分块进行格枚举求解SVP。若枚举算法得到的最短向量不是当前分块的第一个向量，就将最短向量插入到分块前，重新对整个基进行LLL约化。直到对所有分块都操作完毕。这样得到的输出基通常会优于LLL约化基。分块大致可以视为一种滑动窗口，第一个分块是$(\mathbf{b}_1,\ldots,\mathbf{b}_{\beta})$，第二个分块是$(\mathbf{b}_2,\ldots,\mathbf{b}_{\beta + 1})$…总之每次窗口向右移动一个向量。注意最后的$\,\beta-2\,$个分块长度是小于$\,\beta \,$的。</p>
<p><strong>为什么每次插入后要进行LLL呢</strong>？这主要是因为插入的子格最短向量与该子格的基线性相关，因此插入后当前的向量组就不是一组基了。而<strong>LLL能够消去线性相关性</strong>，同时进行一步约化。</p>
<h3 id="理论效能-1"><a href="#理论效能-1" class="headerlink" title="理论效能"></a>理论效能</h3><p>Hanrot等人运用动力系统分析出<strong>BKZ的约化能力下界</strong>为$\, \left|\mathbf{b}_1\right|\le\beta^{\frac{n-1}{2\left(\beta-1\right)}+\frac{3}{2}} \det(B)^\frac{1}{n}\,$。另一方面，当$\, \beta\,$设置为输入格维度$\, n\,$时，由BKZ约化基的定义可知$\, \left|\mathbf{b}_1\right|=\left|\mathbf{b}_1^\ast\right|=\lambda_1\left(\mathcal{L}\right)\,$。此时若BKZ算法能够终止，则其能够成功地求解$\, \mathcal{L}\,$上的SVP问题。<br>    尽管<strong>在实践中BKZ算法较为有效，但它至今仍没有被证明是多项式时间的算法</strong>。2008年，Gama和Nyugen在文指出当时BKZ时间复杂度的理论上界为$\,O\left(n\beta\right)^n\,$，关于维度$\, n\,$为超指数级（当然这也是<strong>悲观上界</strong>）。他们对BKZ进行了大量的实验。实验结果表明<strong>原始BKZ运行时间关于维度$\, n\,$似乎是指数级而不是多项式级</strong>。BKZ 2.0论文中指出，<strong>原始BKZ算法中$\,\beta=20\,$较为实用，但$\,\beta\geq25\,$时运行时间会显著增加</strong>。输入高维格时，选取分块大小为$\, \beta\geq40\,$会使BKZ运行得非常慢，甚至可能跑不出结果。</p>
<h2 id="总结与启发"><a href="#总结与启发" class="headerlink" title="总结与启发"></a>总结与启发</h2><p>前面总结了原始格基规约算法，其中<strong>高斯算法在理论上被研究的很透彻，而LLL和BKZ的理论效能分析结论并不实用，只是算法的下限</strong>。</p>
<p>目前使用的改进LLL算法与改进BKZ算法已经比原始算法的效能好很多，因此<strong>在实战中不使用两种原始算法。</strong>但即便如此原始算法仍然是值得回顾的，很容易受到如下<strong>启发</strong>：</p>
<ol>
<li><strong>理解各算法的优化方向</strong>。对于LLL算法，其改进版的优化主要集中在于大数运算的优化（包括大数算法的改进和浮点数的正确使用），以及使用深插法(deep insertion)提升算法的约化能力；对于BKZ算法，其改进版的优化会集中在SVP oracle（枚举）的调用次数和SVP oracle算法本身的改进，减少运行时间从而能使用更大的$\,\beta\,$。</li>
<li><strong>算法效能很难用理论进行分析</strong>。事实上，大多数使用的<strong>改进后的算法在理论分析上也很困难，结论也不太理想</strong>，并且经典的分析方法不再适用。目前比较有效的理论分析一般是利用启发公式的方法进行启发式估计，设计模拟算法进行实验来得到启发式时间复杂度，许多分析还使用离散动力系统理论作为数学工具。</li>
<li><strong>在大多数场景下BKZ往往比LLL更实用，因为BKZ约化能力更强</strong>。回顾时，我们发现原始BKZ在大多数场景更加实用。只有对求解速度有较大要求或需要在高维格中循环调用算法时才会调用LLL，其他情况下BKZ才是更好的选择。</li>
</ol>
<h1 id="改进格基约化算法"><a href="#改进格基约化算法" class="headerlink" title="改进格基约化算法"></a>改进格基约化算法</h1><p>目前，sagemath中的格基规约算法默认采用fpLLL的实现。在fpLLL中默认的LLL算法依照<a target="_blank" rel="noopener" href="https://www.iacr.org/archive/eurocrypt2005/34940217/34940217.pdf"> $\mathrm{L}^2$算法</a>实现，并结合<a target="_blank" rel="noopener" href="https://perso.ens-lyon.fr/damien.stehle/downloads/HLLL.pdf">H-LLL</a>；默认的BKZ算法主要依照<a target="_blank" rel="noopener" href="https://www.iacr.org/archive/asiacrypt2011/70730001/70730001.pdf">BKZ 2.0</a>实现。对于LLL和BKZ，下面仅简单总结了$\, \mathrm{L}^2\,$算法和BKZ 2.0算法。</p>
<h2 id="mathrm-L-2-算法"><a href="#mathrm-L-2-算法" class="headerlink" title="$\mathrm{L}^{2}$算法"></a>$\mathrm{L}^{2}$算法</h2><p>该算法为一种浮点型LLL算法，其中采用了浮点数和大数运算算法来优化运行时间，并使用deep insertion来提升算法的约化能力。即便不使用大数运算优化，$\, \mathrm{L}^2$算法的理论时间复杂度也为$\, O\!\left(d^4(d+\log B)\,m \log B\right)\,$，远优于原始LLL。（$\,d\,$是格的维度，$\,B\,$是输入基中最长向量的范数，$\,\mathcal{L} \subset \mathbb{R}^{m}$）</p>
<h2 id="BKZ-2-0"><a href="#BKZ-2-0" class="headerlink" title="BKZ 2.0"></a>BKZ 2.0</h2><p>该算法为目前sagemath默认调用的BKZ算法，对原始BKZ算法进行了四个优化：</p>
<ol>
<li><p>将极限剪枝枚举算法(extreme pruning)和一种高概率线性剪枝算法(linear pruning)这两种算法搭配起来，作为BKZ 2.0的SVP oracle（论文中称为sound pruning）。这比最早提出的Schnorr-Euchner剪枝枚举算法还要快很多 。</p>
<p> <em>一次极限剪枝算法的成功概率虽低，但是速度非常快，以至于我们可以通过多次地调用它（例如一百次…），达到一个与其他算法相同的成功概率，速度却能快很多倍。</em></p>
</li>
<li><p>以大量实验结果为依据，使用Gaussian Heuristic启发式对剪枝枚举半径的值进行初始化。具体来说，枚举半径的初始值是1.05GH与输入格基的第一个向量范数中最小的那个。</p>
</li>
<li>使用早期中止技术，合理设置oracle的调用次数（多项式级别）。</li>
<li>对局部基进行预处理。</li>
</ol>
<p>BKZ 2.0的这些优化手段旨在<strong>降低BKZ的SVP oracle调用次数以及SVP oracle自身的运行时间</strong>。这一系列的优化<strong>使得BKZ 2.0可以使用较大的</strong> $\, \beta\,$，从而使得其约化能力显著强于LLL。BKZ 2.0论文中指出，设定算法参数为$\,\beta \ge 90\,$，甚至$\,\beta = 110\,$都是可以的。</p>
<p><em>要想更深入的理解BKZ 2.0，就要学习一下格枚举算法。可以在某英文网站上看一下视频 Lattice-based cryptography II - Enumeration attacks 和  Random Sampling Revisited Lattice Enumeration with Discrete Pruning的前半部分。</em></p>
<p>BKZ 2.0论文是我的外文翻译，不过感觉这篇论文翻译难度较大，我的翻译还需完善一下。如果有人想看的话，可能会在2022年1月完善后放出。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>2004年<strong>高斯算法</strong>被Nguyen等人<strong>推广至高维</strong>，他们指出推广算法在4维格中输出基为欧氏范数为Minkowski约化基（最小基）。同时，在4维格中算法复杂度（就输入基中最长向量范数的比特长度$\,n\,$而言）至少是平方级，若使用快速大数运算方法，算法的时间复杂度有希望提升到$\,O\!\left(n\log{n}\right)\,$级别。论文：<a target="_blank" rel="noopener" href="https://perso.ens-lyon.fr/damien.stehle/downloads/lowdim-final.pdf">Low-Dimensional Lattice Basis Reduction Revisited</a></p>
<p><strong>下面提及的算法在fpLLL中也有实现。</strong></p>
<p><strong>H-LLL</strong>以$\,\mathrm{L}^2$算法为基础，在计算施密特正交化（QR分解）时使用householder算法替换了 Cholesky算法从而加快了运行速度。（具体做法并没这么简单，为了防止精度损失导致结果与原来不同，整个算法被重组）。论文：<a target="_blank" rel="noopener" href="https://perso.ens-lyon.fr/damien.stehle/downloads/HLLL.pdf">H-LLL: Using Householder Inside LLL</a></p>
<p>2008年，Gama和Nyugen提出了<strong>slide reduction</strong>。算法结构很漂亮，并且它的理论效能强于使用中止技术的BKZ。不过最初的slide reduction算法，其实际表现远不如BKZ 2.0算法。论文：Finding Short Lattice Vectors within Mordell’s Inequality</p>
<p>2016年， Micciancio和Walter获得了很大成果。他们提出一种在<strong>对偶格上枚举最短向量</strong>的方法，并且这种方法不需要计算对偶基。这使得他们能够在slide reduction使用很大的block size。改进后的slide reduction，其效能与BKZ 2.0几乎差不多。并且更重要的是，<strong>在block size的值适中时，其理论效能与实际效能几乎一致。这意味着无需进行实验就可以估计格基约化算法对格密码的冲击。</strong>此外，他们还<strong>提出一种SDBKZ</strong>(self dual BKZ，即自对偶BKZ)，其实际效能与BKZ 2.0相差无几，但其理论效能很容易分析。总之，这篇论文对于想进一步了解格基规约算法的人来说<strong>非常值得阅读</strong>。论文：<a target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-3-662-49890-3_31">Practical, Predictable Lattice Basis Reduction</a></p>
<p>此外也推荐这些博客，与上面的内容相关：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/04/lattice-blog-reduction-part-i-bkz/">Lattice Blog Reduction – Part I: BKZ | Calvin Café: The Simons Institute Blog</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/05/lattice-blog-reduction-part-ii-slide-reduction/">Lattice Blog Reduction – Part II: Slide Reduction | Calvin Café: The Simons Institute Blog</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/08/lattice-blog-reduction-part-iii-self-dual-bkz/">Lattice Blog Reduction – Part III: Self-Dual BKZ | Calvin Café: The Simons Institute Blog</a></p>
</li>
</ul>
<p><strong>目前最强的算法是基于G6K的BKZ</strong>（全称General Sieve Kernel，读作Jessica），可以在英文网站上查找相关的讲解视频。论文：<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2019/089">The General Sieve Kernel and New Records in Lattice Reduction</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h2><p>为了保证阅读体验，我没有在正文标注引用。本人只是把这方面内容重新组织和总结了一下，又写了一点自己的理解。根据以下论文的名字不难找到本文内容的出处。</p>
<ol>
<li><p>Hoffstein J , Pipher J C , Silverman J H . An Introduction to Mathematical Cryptography. 2008.</p>
</li>
<li><p>Galbraith S D . Mathematics of Public Key Cryptography: Lattices. 2012.</p>
</li>
<li><p>Nguyen P Q , D Stehlé. Low-Dimensional Lattice Basis Reduction Revisited. 2009.</p>
</li>
<li><p>Lenstra A . Factoring polynomial with rational coefficients. 1982.</p>
</li>
<li><p>Bremner M R . Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications.  2011.</p>
</li>
<li><p>Schnorr C P, Euchner M. Lattice basis reduction: improved practical algorithms and solving subset sum problems. 1994.</p>
</li>
<li><p>Gama, Nicolas, et al. “Lattice Enumeration Using Extreme Pruning.” EUROCRYPT’10 Proceedings of the 29th Annual International Conference on Theory and Applications of Cryptographic Techniques, 2010, pp. 257–278.</p>
</li>
<li><p>Chen Y, Nguyen P Q. BKZ 2.0: Better lattice security estimates. 2011.</p>
</li>
<li><p>PQ Nguyen, D Stehlé. Floating-Point LLL Revisited. 2005.</p>
</li>
<li><p>郑永辉,刘永杰,栾鸾.格基约化算法及其在密码分析中的应用综述. 2020.</p>
</li>
<li><p>Regev L O , Kaplan S E . Lattices in Computer Science LLL Algorithm. 2013.</p>
</li>
<li><p>Cohen H . A Course in Computational Algebraic Number Theory. 2013.</p>
</li>
<li><p>Hanrot G, Pujol X, Stehlé. Analyzing blockwise lattice algorithms using dynamical systems. 2011.</p>
</li>
<li><p>Gama N, Nguyen P Q. Predicting lattice reduction. 2008.</p>
</li>
<li><p>Morel I, Stehlé D, Villard G. H-LLL: using householder inside LLL. 2009.</p>
</li>
</ol>
<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p><a target="_blank" rel="noopener" href="https://kel.bz/post/lll/">Building Lattice Reduction (LLL) Intuition | kel.bz</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/04/lattice-blog-reduction-part-i-bkz/">Lattice Blog Reduction – Part I: BKZ | Calvin Café: The Simons Institute Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/05/lattice-blog-reduction-part-ii-slide-reduction/">Lattice Blog Reduction – Part II: Slide Reduction | Calvin Café: The Simons Institute Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/08/lattice-blog-reduction-part-iii-self-dual-bkz/">Lattice Blog Reduction – Part III: Self-Dual BKZ | Calvin Café: The Simons Institute Blog</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.simons.berkeley.edu/2020/08/lattice-blog-reduction-part-iii-self-dual-bkz/">Lattice Blog Reduction – Part III: Self-Dual BKZ | Calvin Café: The Simons Institute Blog</a></p>
<p><em>还有一些英文视频，因为一些你懂得的原因这里就不贴了。</em></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">随缘(su1yu4n)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://su1yu4n.github.io/2021/06/20/格基规约算法：算法详解/">https://su1yu4n.github.io/2021/06/20/格基规约算法：算法详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://su1yu4n.github.io">随缘的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%BC%E8%AE%BA%EF%BC%88%E5%87%A0%E4%BD%95%E6%95%B0%E8%AE%BA%EF%BC%89/">格论（几何数论）</a><a class="post-meta__tags" href="/tags/%E6%A0%BC%E5%9F%BA%E8%A7%84%E7%BA%A6%E7%AE%97%E6%B3%95/">格基规约算法</a><a class="post-meta__tags" href="/tags/%E6%A0%BC%E5%AF%86%E7%A0%81%E5%AD%A6/">格密码学</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/06/20/%E6%A0%BC%E5%9F%BA%E8%A7%84%E7%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"><i class="fa fa-chevron-left">  </i><span>格基规约算法：数学基础</span></a></div><div class="next-post pull-right"><a href="/2021/03/04/%E8%B0%83%E6%95%B4%E5%85%89%E7%8C%AB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"><span>记一次对家中网络的简单优化</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: 'su1yu4n',
  repo: 'su1yu4n.github.io/',
  oauth: {
    client_id: 'bd1c8c53a34d711c325c',
    client_secret: 'e4c33be6bfd85795a047c2269592ec1a9e738146'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2024 By 随缘(su1yu4n)</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>